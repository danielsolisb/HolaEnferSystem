"appointments_admin.txt"
from django.contrib import admin
from django.utils.translation import gettext_lazy as _
from .models import AppointmentStatus, Schedule, Appointment

@admin.register(AppointmentStatus)
class AppointmentStatusAdmin(admin.ModelAdmin):
    list_display    = ('nombre', 'descripcion')
    search_fields   = ('nombre',)
    ordering        = ('nombre',)

@admin.register(Schedule)
class ScheduleAdmin(admin.ModelAdmin):
    list_display    = ('enfermero', 'fecha', 'hora_inicio', 'hora_fin', 'disponible')
    list_filter     = ('enfermero', 'fecha', 'disponible')
    search_fields   = ('enfermero__nombres',)
    date_hierarchy  = 'fecha'
    raw_id_fields   = ('enfermero',)

@admin.register(Appointment)
class AppointmentAdmin(admin.ModelAdmin):
    list_display = (
        'paciente',
        'servicio',
        'enfermero',
        'horario',
        'hora',
        'estado',
        'tipo_ubicacion',  # Nuevo campo en admin
        'ubicacion',
        'mapa_ubicacion', 
        'doctor_name',
        'diagnosis', # Añadido aquí también
        'asignado_por',
        'fecha_creacion',
    )
    list_filter     = (
        'estado',
        'enfermero',  # ← nuevo campo aquí
        'horario__fecha',
        'horario__enfermero',
        'asignado_por',
    )
    search_fields   = (
        'paciente__nombres',
        'servicio__nombre',
        'asignado_por__email',
        'enfermero__email',  # ← puedes buscar por email del enfermero
    )
    date_hierarchy  = 'horario__fecha'
    raw_id_fields   = (
        'paciente',
        'servicio',
        'producto',
        'horario',
        'estado',
        'asignado_por',
        'enfermero',  # ← nuevo campo aquí
    )
    #filter_horizontal = ('producto',)  # ← Esto activa un widget útil para seleccionar productos M2M
    fieldsets = (
    (None, {
        'fields': (
                'paciente',
                'enfermero',
                'servicio',
                'producto',
                'tipo_ubicacion',
                'ubicacion',
                'mapa_ubicacion',  # Añadido aquí también
                'horario',
                'hora',
                'estado',
                'asignado_por',
                'notas',
                'doctor_name',
                'diagnosis',
            )
        }),
        (_('Tiempos'), {
            'fields': ('fecha_creacion', 'fecha_modifica'),
        }),
    )
    readonly_fields = ('fecha_creacion', 'fecha_modifica')


"appointments_apps.txt"
from django.apps import AppConfig


class AppointmentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'CoreApps.appointments'


"appointments_forms.txt"
from django import forms
from .models import Appointment
from CoreApps.catalog.models import Product
from django.forms.widgets import SelectDateWidget
from django.core.exceptions import ValidationError
from .models import Schedule

class AppointmentForm(forms.ModelForm):
    class Meta:
        model = Appointment
        #fields = [
        #    'paciente',
        #    'servicio',
        #    'producto',
        #    'enfermero',
        #    'fecha',
        #    'hora',
        #    'estado',
        #    'notas',
        #]
        fields = [
            'paciente', 'servicio', 'producto',
            'tipo_ubicacion', 'ubicacion', 'mapa_ubicacion',  # Añade aquí
            'enfermero', 'fecha', 'hora', 'estado', 'notas',
        ]

        widgets = {
            #'paciente': forms.Select(attrs={'class': 'form-control'}),
            'servicio': forms.Select(attrs={'class': 'form-control'}),
            'producto': forms.Select(attrs={'class': 'form-control'}),
            'tipo_ubicacion': forms.RadioSelect(),
            'ubicacion': forms.Textarea(attrs={
                'class': 'form-control', 'rows': 2,
                'placeholder': 'Dirección de la cita'
            }),
            'mapa_ubicacion': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enlace al mapa de Google'
            }),
            'doctor_name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Nombre del doctor'
            }),
            'diagnosis': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 3,
                'placeholder': 'Diagnóstico médico'
            }),
            'enfermero': forms.Select(attrs={'class': 'form-control'}),
            'horario': forms.Select(attrs={'class': 'form-control'}),
            'fecha': forms.DateInput(attrs={'type': 'date', 'class': 'form-control'}),
            'hora': forms.TimeInput(attrs={'type': 'time', 'class': 'form-control'}),
            'estado': forms.Select(attrs={'class': 'form-control'}),
            'notas': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }
    def clean(self):
        cleaned_data = super().clean()
        enfermero = cleaned_data.get('enfermero')
        fecha = cleaned_data.get('fecha')
        hora = cleaned_data.get('hora')
        paciente  = cleaned_data.get('paciente')
        tipo_ubi  = cleaned_data.get('tipo_ubicacion')
        ubi       = cleaned_data.get('ubicacion')

        if enfermero and fecha and hora:
            try:
                horario = Schedule.objects.get(
                    enfermero=enfermero,
                    fecha=fecha,
                    hora_inicio__lte=hora,
                    hora_fin__gte=hora,
                    disponible=True
                )
                self.instance.horario = horario  # ← AQUÍ ASIGNAMOS ANTES DE VALIDAR EL MODELO
            except Schedule.DoesNotExist:
                raise forms.ValidationError("No se encontró un horario disponible para esta fecha y hora seleccionada.")

        if tipo_ubi == 'domicilio':
            if paciente and paciente.direccion and paciente.ubicacion_mapa:
                cleaned_data['ubicacion'] = paciente.direccion
                cleaned_data['mapa_ubicacion'] = paciente.ubicacion_mapa
                self.instance.ubicacion = paciente.direccion
                self.instance.mapa_ubicacion = paciente.ubicacion_mapa
            else:
                raise ValidationError("El cliente no tiene dirección o mapa registrados.")
        else:  # 'otro'
            if not ubi or not cleaned_data.get('mapa_ubicacion'):
                raise ValidationError("Debe indicar la ubicación y el enlace del mapa para la cita.")
            self.instance.ubicacion = ubi
            self.instance.mapa_ubicacion = cleaned_data['mapa_ubicacion']

        return cleaned_data

        

    #def clean(self):
    #    cleaned = super().clean()
    #    enfermero = cleaned.get('enfermero')
    #    fecha = cleaned.get('fecha')
    #    hora = cleaned.get('hora')
#
    #    if enfermero and fecha and hora:
    #        conflicto = Appointment.objects.filter(
    #            enfermero=enfermero,
    #            fecha=fecha,
    #            hora=hora
    #        )
    #        if self.instance.pk:
    #            conflicto = conflicto.exclude(pk=self.instance.pk)
#
    #        if conflicto.exists():
    #            raise ValidationError(
    #                f"Ya existe una cita asignada al enfermero {enfermero} el {fecha} a las {hora}.",
    #                code='duplicate_appointment'
    #            )
#
    #    return cleaned

class ScheduleForm(forms.ModelForm):
    class Meta:
        model = Schedule
        fields = ['fecha', 'hora_inicio', 'hora_fin']
        widgets = {
            'fecha': forms.DateInput(attrs={'type': 'date', 'class': 'form-control'}),
            'hora_inicio': forms.TimeInput(attrs={'type': 'time', 'class': 'form-control'}),
            'hora_fin': forms.TimeInput(attrs={'type': 'time', 'class': 'form-control'}),
        }

"appointments_models.txt"
# CoreApps/appointments/models.py

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _
from CoreApps.customers.models import CustomerProfile
from CoreApps.catalog.models import Service
from django.core.exceptions import ValidationError  # ← Añade esta línea
from CoreApps.catalog.models import Service, Product  # Asegúrate de importar Product también

class AppointmentStatus(models.Model):
    nombre       = models.CharField(_("Estado"), max_length=50, unique=True)
    descripcion  = models.TextField(_("Descripción"), blank=True)

    class Meta:
        verbose_name        = _("Estado de Cita")
        verbose_name_plural = _("Estados de Citas")

    def __str__(self):
        return self.nombre



class Schedule(models.Model):
    enfermero     = models.ForeignKey(
                        settings.AUTH_USER_MODEL,
                        limit_choices_to={'rol': 'enfermero'},
                        on_delete=models.CASCADE,
                        related_name='horarios'
                    )
    fecha         = models.DateField(_("Fecha"))
    hora_inicio   = models.TimeField(_("Hora de inicio"))
    hora_fin      = models.TimeField(_("Hora de fin"))
    disponible    = models.BooleanField(_("Disponible"), default=True)

    class Meta:
        verbose_name        = _("Horario")
        verbose_name_plural = _("Horarios")
        unique_together     = ('enfermero', 'fecha', 'hora_inicio', 'hora_fin')

    def __str__(self):
        return f"{self.enfermero.nombres} — {self.fecha} {self.hora_inicio}-{self.hora_fin}"



class Appointment(models.Model):
    paciente        = models.ForeignKey(
                         CustomerProfile,
                         on_delete=models.CASCADE,
                         related_name='citas'
                       )
    servicio        = models.ForeignKey(
                         Service,
                         on_delete=models.PROTECT,
                         related_name='citas'
                       )
    enfermero       = models.ForeignKey(
                        settings.AUTH_USER_MODEL,
                        on_delete=models.PROTECT,
                        related_name='citas_asignadas',
                        limit_choices_to={'rol': 'enfermero'},
                        verbose_name=_("Enfermero asignado"),
                        blank=True, null=True
                       )
    horario         = models.ForeignKey(
                         Schedule,
                         on_delete=models.PROTECT,
                         related_name='citas'
                       )
    fecha           = models.DateField(_("Fecha de la cita"), null=True, blank=True)
    hora            = models.TimeField(_("Hora de la cita"), null=True, blank=True)   
    # Ubicación de la cita
    TIPO_UBICACION = [
        ('domicilio', 'En domicilio'),
        ('otro',      'Otra ubicación'),
    ]
    tipo_ubicacion = models.CharField(
        _("Tipo de ubicación"),
        max_length=10,
        choices=TIPO_UBICACION,
        default='domicilio'
    )
    ubicacion = models.TextField(
        _("Ubicación de la cita"),
        blank=True,
        help_text="Si es en domicilio, se copiará la dirección del cliente."
    )
    mapa_ubicacion = models.URLField(
        _("Ubicación en Google Maps"),
        max_length=500,
        blank=True,
        null=True,
        help_text=_("Enlace a Google Maps para la cita.")
    )
    # —————————————————————————————————————————
    estado          = models.ForeignKey(
                         AppointmentStatus,
                         on_delete=models.PROTECT,
                         related_name='citas'
                       )
    asignado_por    = models.ForeignKey(
                         settings.AUTH_USER_MODEL,
                         on_delete=models.SET_NULL,
                         null=True,
                         related_name='citas_agendadas'
                       )
    #productos       = models.ManyToManyField(Product, blank=True, related_name='citas')  # ← NUEVO
    producto        = models.ForeignKey(Product, on_delete=models.PROTECT, verbose_name=_("Producto aplicado"), null=True, blank=True)  # ← NUEVO (null=True, blank=True)
    doctor_name     = models.CharField(_("Doctor"), max_length=200, blank=True, null=True)
    diagnosis       = models.TextField(_("Diagnóstico"), blank=True, null=True)
    notas           = models.TextField(_("Notas adicionales"), blank=True, null=True)
    fecha_creacion  = models.DateTimeField(_("Creado en"), auto_now_add=True)
    fecha_modifica  = models.DateTimeField(_("Última modificación"), auto_now=True)

    class Meta:
        verbose_name        = _("Cita")
        verbose_name_plural = _("Citas")
        ordering            = ['horario__fecha', 'horario__hora_inicio']

    def __str__(self):
        return f"Cita {self.paciente.nombres} — {self.horario.fecha} {self.hora}"
    
    def clean(self):
        #if self.hora < self.horario.hora_inicio or self.hora > self.horario.hora_fin:
        #    raise ValidationError({
        #        'hora': _(
        #            f"La hora de la cita debe estar entre "
        #            f"{self.horario.hora_inicio} y {self.horario.hora_fin}."
        #        )
        #    })
    
        if self.horario and self.enfermero and self.horario.enfermero != self.enfermero:
            raise ValidationError({
                'horario': _("Este horario no pertenece al enfermero seleccionado.")
            })

        if self.enfermero and self.fecha and self.hora:
            from datetime import timedelta, datetime
        
            hora_inicio_cita = datetime.combine(self.fecha, self.hora)
            hora_fin_cita = hora_inicio_cita + timedelta(hours=1)  # ← asumimos duración de 1 hora
        
            conflictos = Appointment.objects.filter(
                enfermero=self.enfermero,
                fecha=self.fecha
            ).exclude(pk=self.pk)
        
            for cita in conflictos:
                inicio_existente = datetime.combine(cita.fecha, cita.hora)
                fin_existente = inicio_existente + timedelta(hours=1)
        
                # Verifica si se solapan
                if inicio_existente < hora_fin_cita and hora_inicio_cita < fin_existente:
                    raise ValidationError({
                        'hora': _(
                            f"Ya existe una cita para este enfermero entre "
                            f"{inicio_existente.time().strftime('%H:%M')} y {fin_existente.time().strftime('%H:%M')}."
                        )
                    })


        #if self.enfermero and self.fecha and self.hora:
        #    ya_existe = Appointment.objects.filter(
        #        enfermero=self.enfermero,
        #        fecha=self.fecha,
        #        hora=self.hora
        #    )
        #    # Si está editando, excluye el mismo objeto
        #    if self.pk:
        #        ya_existe = ya_existe.exclude(pk=self.pk)
    #
        #    if ya_existe.exists():
        #        raise ValidationError({
        #            'hora': _("Ya existe una cita para este enfermero en esta fecha y hora.")
        #        })


"appointments_urls.txt"
from django.urls import path
from . import views

app_name = 'appointments'

urlpatterns = [
    path('', views.AppointmentListView.as_view(), name='appointment-list'),
    path('nuevo/', views.AppointmentCreateView.as_view(), name='appointment-create'),
    path('<int:pk>/detalle/', views.AppointmentDetailView.as_view(), name='appointment-detail'),
    path('<int:pk>/editar/', views.AppointmentUpdateView.as_view(), name='appointment-update'),
    path('<int:pk>/eliminar/', views.AppointmentDeleteView.as_view(), name='appointment-delete'),
    path('horarios/nuevo/', views.ScheduleCreateView.as_view(), name='nuevo-horario'),
    path('horarios/mis-horarios/', views.ScheduleListView.as_view(), name='mis-horarios'),
    path('horarios/editar/<int:pk>/', views.ScheduleUpdateView.as_view(), name='editar-horario'),
    path('horarios/eliminar/<int:pk>/', views.ScheduleDeleteView.as_view(), name='eliminar-horario'),
    path('api/pacientes/', views.obtener_pacientes_por_ciudad, name='api-obtener-pacientes'),
    path('api/horarios/', views.obtener_horarios_por_enfermero, name='api-obtener-horarios'),
    path('api/enfermeros/', views.obtener_enfermeros_por_ciudad, name='api-enfermeros'),

    path('mis-citas/', views.AssignedAppointmentListView.as_view(), name='mis-citas'),
    path('mis-citas/<int:pk>/', views.AssignedAppointmentDetailView.as_view(), name='mis-citas-detail'),

 # --- NUEVAS URLs para Call Center ---
    path('callcenter/crear/', views.CallCenterAppointmentCreateView.as_view(), name='callcenter-appointment-create'),
    path('callcenter/api/disponibilidad/', views.CallCenterAvailabilityAPIView.as_view(), name='callcenter-api-availability'),
    path('callcenter/api/enfermeros-slot/', views.CallCenterNursesForSlotAPIView.as_view(), name='callcenter-api-nurses-for-slot'),
    # Usaremos la API existente de customers para zonas
    # Podríamos necesitar una para buscar/crear paciente si la existente no basta
    path('callcenter/api/buscar-crear-paciente/', views.CallCenterFindCreatePatientAPIView.as_view(), name='callcenter-api-find-create-patient'), # Nueva API

 # --- NUEVAS URLs CRUD para Call Center ---
    # Listado de Citas para Call Center
    path('callcenter/listado/', views.CallCenterAppointmentListView.as_view(), name='callcenter-appointment-list'),
    # Detalle de Cita para Call Center (si necesitas una vista de detalle diferente)
    # Podrías reutilizar la original 'appointment-detail' o crear una nueva si la vista es muy distinta
    path('callcenter/<int:pk>/detalle/', views.CallCenterAppointmentDetailView.as_view(), name='callcenter-appointment-detail'),
    # Edición de Cita para Call Center
    path('callcenter/<int:pk>/editar/', views.CallCenterAppointmentUpdateView.as_view(), name='callcenter-appointment-update'),
    # Eliminación de Cita para Call Center
    path('callcenter/<int:pk>/eliminar/', views.CallCenterAppointmentDeleteView.as_view(), name='callcenter-appointment-delete'),


]



"appointments_views.txt"
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import ListView, CreateView, UpdateView, DetailView, DeleteView
from django.contrib.auth.mixins import UserPassesTestMixin
from django.urls import reverse_lazy
from .models import Appointment
from .forms import AppointmentForm
from .forms import ScheduleForm
from django.http import JsonResponse

from CoreApps.core.models import City
from .models import Appointment, Schedule, AppointmentStatus #
from django.utils import timezone
from datetime import datetime, timedelta
from django.contrib.auth import get_user_model

from django.views import View
from django.db.models import Q, Subquery, OuterRef
from django.utils.dateparse import parse_date, parse_datetime
from django.db import transaction # Import transaction


from django.shortcuts import get_object_or_404 # Import get_object_or_404
import json # Import json for request body parsing

#render
from django.shortcuts import render

# --- Modelos y Forms de OTRAS apps (AQUÍ ESTÁ LA CLAVE) ---
from CoreApps.customers.models import CustomerProfile
from CoreApps.customers.forms import CustomerProfileForm # La usas en la API de paciente
from CoreApps.core.models import City, Zona
from CoreApps.catalog.models import Service # Ya importas Service
from CoreApps.catalog.models import Product


User = get_user_model()

# Listar todas las citas (operador y administrador)
class AppointmentListView(LoginRequiredMixin, ListView):
    model = Appointment
    template_name = 'main/appointments/appointment_list.html'
    context_object_name = 'appointments'

    def get_queryset(self):
        return Appointment.objects.select_related(
            'paciente', 'servicio', 'horario', 'estado'
        ).prefetch_related('producto').order_by('-fecha_creacion')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Citas"
        context['subtitle'] = "Listado de citas agendadas"
        return context

# Crear nueva cita
class AppointmentCreateView(LoginRequiredMixin, CreateView):
    model = Appointment
    form_class = AppointmentForm
    template_name = 'main/appointments/appointment_form1.html'
    success_url = reverse_lazy('appointments:appointment-list')

    def form_valid(self, form):
        form.instance.asignado_por = self.request.user
        form.instance.paciente_id = self.request.POST.get('paciente')
        return super().form_valid(form)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Nueva Cita"
        context['subtitle'] = "Agendar cita para paciente"
        context['ciudades'] = City.objects.all()
        return context

# Detalle de una cita
class AppointmentDetailView(LoginRequiredMixin, DetailView):
    model = Appointment
    template_name = 'main/appointments/appointment_detail.html'
    context_object_name = 'appointment'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Detalle de Cita"
        context['subtitle'] = "Información completa"
        return context

# Editar cita
class AppointmentUpdateView(LoginRequiredMixin, UpdateView):
    model = Appointment
    form_class = AppointmentForm
    template_name = 'main/appointments/appointment_form1.html'
    success_url = reverse_lazy('appointments:appointment-list')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Editar Cita"
        context['subtitle'] = "Modificar datos"
        context['ciudades'] = City.objects.all()
        # Datos iniciales solo si existe objeto (modo edición)
        context['ciudad_inicial'] = self.object.paciente.ciudad_id if self.object.paciente else None
        context['paciente_inicial'] = self.object.paciente_id
        context['enfermero_inicial'] = self.object.enfermero_id
        context['horario_inicial'] = self.object.horario_id
        context['hora_inicial'] = self.object.hora.strftime("%H:%M") if self.object.hora else ''
        context['zona_inicial'] = (
            self.object.paciente.zona_id
            if self.object.paciente and self.object.paciente.zona_id
            else None
        )
        context['mapa_inicial'] = self.object.mapa_ubicacion if self.object.mapa_ubicacion else ''

        return context

# Eliminar cita
class AppointmentDeleteView(LoginRequiredMixin, DeleteView):
    model = Appointment
    template_name = 'main/appointments/appointment_confirm_delete.html'
    success_url = reverse_lazy('appointments:appointment-list')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Eliminar Cita"
        context['subtitle'] = "Confirmación de eliminación"
        return context

class ScheduleCreateView(LoginRequiredMixin, CreateView):
    model = Schedule
    form_class = ScheduleForm
    template_name = 'main/appointments/schedule_form.html'
    success_url = reverse_lazy('appointments:mis-horarios')

    def form_valid(self, form):
        form.instance.enfermero = self.request.user
        return super().form_valid(form)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Establecer Horarios"
        context['subtitle'] = "Agendar horarios"
        return context

class ScheduleListView(LoginRequiredMixin, ListView):
    model = Schedule
    template_name = 'main/appointments/schedule_list.html'
    context_object_name = 'horarios'

    def get_queryset(self):
        # Base: sólo los horarios del usuario
        qs = Schedule.objects.filter(enfermero=self.request.user)
        # Leemos ?date=YYYY-MM-DD
        date_str = self.request.GET.get('date')
        if date_str:
            try:
                selected = datetime.strptime(date_str, '%Y-%m-%d').date()
            except ValueError:
                selected = timezone.localdate()
        else:
            selected = timezone.localdate()
        # Guardamos en la instancia para usar en el contexto
        self.selected_date = selected
        # Filtramos por esa fecha y ordenamos por hora
        return qs.filter(fecha=selected).order_by('hora_inicio')
    #def get_queryset(self):
    #    return Schedule.objects.filter(enfermero=self.request.user).order_by('-fecha', 'hora_inicio')
    
    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        ctx.update({
            'title': "Lista de Horarios",
            'subtitle': f"Horarios para {self.selected_date.strftime('%d/%m/%Y')}",
            'selected_date': self.selected_date.isoformat(),
        })
        return ctx
    #def get_context_data(self, **kwargs):
    #    context = super().get_context_data(**kwargs)
    #    context['title'] = "Lista de Horarios"
    #    context['subtitle'] = "horarios"
    #    return context

class ScheduleUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    model = Schedule
    form_class = ScheduleForm
    template_name = 'main/appointments/schedule_form.html'
    success_url = reverse_lazy('appointments:mis-horarios')

    def test_func(self):
        return self.get_object().enfermero == self.request.user
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Editar Horario"
        context['subtitle'] = "Editar"
        return context

class ScheduleDeleteView(LoginRequiredMixin, UserPassesTestMixin, DeleteView):
    model = Schedule
    template_name = 'main/appointments/schedule_confirm_delete.html'
    success_url = reverse_lazy('appointments:mis-horarios')

    def test_func(self):
        return self.get_object().enfermero == self.request.user



def obtener_pacientes_por_ciudad(request):
    
    ciudad_id = request.GET.get('ciudad_id')
    zona_id   = request.GET.get('zona_id')
    if not ciudad_id:
        return JsonResponse([], safe=False)

    # Base QS filtrada por ciudad, y si llega zona_id, filtramos por zona
    qs = CustomerProfile.objects.filter(ciudad_id=ciudad_id)
    #qs = CustomerProfile.objects.filter(ciudad_id=ciudad_id)
    if zona_id:
        qs = qs.filter(zona_id=zona_id)
    #pacientes = qs.values('id', 'nombres', 'apellidos', 'cedula')
    pacientes = qs.values('id', 'nombres', 'apellidos', 'cedula', 'direccion', 'ubicacion_mapa')
    data = [
        {
            'id': p['id'],
            #'nombre': f"{p['nombres']} {p['apellidos']} ({p['cedula']})"
            'nombre': f"{p['nombres']} {p['apellidos']} ({p['cedula']})",
            'direccion': p['direccion'],
            'mapa': p['ubicacion_mapa']  # Añade esta línea
        }
        for p in pacientes
    ]
    return JsonResponse(data, safe=False)

def obtener_horarios_por_enfermero(request):
    enfermero_id = request.GET.get('enfermero_id')
    if not enfermero_id:
        return JsonResponse([], safe=False)

    horarios = Schedule.objects.filter(enfermero_id=enfermero_id, disponible=True).order_by('fecha', 'hora_inicio')
    data = []

    for h in horarios:
        # Obtener horas ocupadas en citas para este horario
        citas = Appointment.objects.filter(enfermero_id=enfermero_id, horario_id=h.id)
        horas_ocupadas = [c.hora.strftime("%H:%M") for c in citas]

        data.append({
            'id': h.id,
            'texto': f"{h.fecha} - {h.hora_inicio} a {h.hora_fin}",
            'fecha': h.fecha.strftime("%Y-%m-%d"),
            'hora_inicio': h.hora_inicio.strftime("%H:%M"),
            'hora_fin': h.hora_fin.strftime("%H:%M"),
            'ocupadas': horas_ocupadas  # NUEVO CAMPO
        })

    return JsonResponse(data, safe=False)
#def obtener_horarios_por_enfermero(request):
#    enfermero_id = request.GET.get('enfermero_id')
#    if not enfermero_id:
#        return JsonResponse([], safe=False)
#
#    horarios = Schedule.objects.filter(enfermero_id=enfermero_id, disponible=True).order_by('fecha', 'hora_inicio')
#    data = [
#        {
#            'id': h.id,
#            'texto': f"{h.fecha} - {h.hora_inicio} a {h.hora_fin}",
#            'fecha': h.fecha.strftime("%Y-%m-%d"),  # lo importante
#            'hora_inicio': h.hora_inicio.strftime("%H:%M"),
#            'hora_fin': h.hora_fin.strftime("%H:%M"),
#        }
#        for h in horarios
#    ]
#    return JsonResponse(data, safe=False)

def obtener_enfermeros_por_ciudad(request):
    ciudad_id = request.GET.get('ciudad_id')
    zona_id   = request.GET.get('zona_id')
    if not ciudad_id:
        return JsonResponse([], safe=False)

    # Filtramos por ciudad y, si existe zona_id, por esa zona (M2M)
    qs = User.objects.filter(rol='enfermero', ciudad_id=ciudad_id)
    if zona_id:
        qs = qs.filter(zonas__id=zona_id)
    enfermeros = qs.values('id', 'nombres', 'email')
    data = [
        {
            'id': e['id'],
            'nombre': f"{e['nombres']} ({e['email']})"
        }
        for e in enfermeros
    ]
    return JsonResponse(data, safe=False)


#citas de enfermeros logeados para realizar la visualizacion y gestion de las mismas
class AssignedAppointmentListView(LoginRequiredMixin, ListView):
    model = Appointment
    template_name = 'main/appointments/enfermero_appointment_list.html'
    context_object_name = 'appointments'

    def get_queryset(self):
        qs = Appointment.objects.filter(enfermero=self.request.user)
        date_str = self.request.GET.get('date')
        if date_str:
            try:
                selected = datetime.strptime(date_str, '%Y-%m-%d').date()
            except ValueError:
                selected = timezone.localdate()
        else:
            selected = timezone.localdate()
        self.selected_date = selected
        return qs.filter(horario__fecha=selected).order_by('horario__fecha', 'hora')
        
    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        ctx['selected_date'] = self.selected_date.isoformat()
        ctx['title']    = "Mis Citas Asignadas"
        ctx['subtitle'] = f"Citas para {self.selected_date.strftime('%d/%m/%Y')}"
        return ctx
    
    #def get_queryset(self):
    #    return Appointment.objects.filter(
    #        enfermero=self.request.user
    #    ).order_by('horario__fecha', 'hora')

class AssignedAppointmentDetailView(LoginRequiredMixin, DetailView):
    model = Appointment
    template_name = 'main/appointments/enfermero_appointment_detail.html'
    context_object_name = 'appointment'


# --- NUEVAS VISTAS API para Call Center ---

class CallCenterAvailabilityAPIView(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        zona_id = request.GET.get('zona_id')
        start_date_str = request.GET.get('start_date')
        end_date_str = request.GET.get('end_date')

        if not zona_id or not start_date_str or not end_date_str:
            return JsonResponse({'error': 'Parámetros zona_id, start_date, end_date requeridos'}, status=400)

        try:
            # Validación de Cobertura (Paso 1 del flujo)
            zona = Zona.objects.get(pk=zona_id)
        except Zona.DoesNotExist:
             return JsonResponse({'error': f'Zona con id {zona_id} no encontrada. No hay cobertura.'}, status=404)

        start_date = parse_date(start_date_str)
        end_date = parse_date(end_date_str)

        if not start_date or not end_date or start_date > end_date:
            return JsonResponse({'error': 'Fechas inválidas'}, status=400)

        availability_data = {}

        # 1. Encontrar enfermeros para la zona
        # Asume que User tiene ManyToManyField 'zonas'
        nurses_in_zone = User.objects.filter(rol='enfermero', zonas__id=zona_id, is_active=True)
        nurse_ids = list(nurses_in_zone.values_list('id', flat=True))

        if not nurse_ids:
             # Si no hay enfermeros, no hay disponibilidad
             return JsonResponse(availability_data, safe=False)

        # 2. Obtener todos los horarios relevantes
        schedules = Schedule.objects.filter(
            enfermero_id__in=nurse_ids,
            fecha__range=[start_date, end_date],
            disponible=True
        ).values('id', 'enfermero_id', 'fecha', 'hora_inicio', 'hora_fin')

        # 3. Obtener todas las citas existentes relevantes
        existing_appointments = Appointment.objects.filter(
            enfermero_id__in=nurse_ids,
            fecha__range=[start_date, end_date] # Usar el campo fecha de Appointment
        ).values('enfermero_id', 'fecha', 'hora') # Usar fecha y hora de Appointment

        # 4. Procesar y calcular slots libres (Lógica compleja)
        # Esta parte requiere iterar por días, luego por schedules de ese día,
        # generar slots (ej. cada hora), y verificar contra existing_appointments.
        # Es un ejemplo simplificado. Necesitarás ajustar la granularidad (ej. cada 30 min).

        booked_slots = {} # {(enfermero_id, fecha, hora_str): True}
        for appt in existing_appointments:
            if appt['hora']:
                 hora_str = appt['hora'].strftime('%H:%M')
                 key = (appt['enfermero_id'], appt['fecha'], hora_str)
                 booked_slots[key] = True

        current_date = start_date
        while current_date <= end_date:
            date_str = current_date.strftime('%Y-%m-%d')
            availability_data[date_str] = {}
            # Filtrar schedules para el día actual
            day_schedules = [s for s in schedules if s['fecha'] == current_date]

            # Asumimos slots de 1 hora por simplicidad
            for hour in range(0, 24): # Iterar horas del día
                slot_time = datetime.strptime(f"{hour:02d}:00", '%H:%M').time()
                slot_datetime_start = datetime.combine(current_date, slot_time)

                available_nurses_for_slot = []

                for nurse_id in nurse_ids:
                    is_available = False
                    # Verificar si el enfermero tiene un schedule que cubra este slot
                    for schedule in day_schedules:
                        if schedule['enfermero_id'] == nurse_id and \
                           schedule['hora_inicio'] <= slot_time < schedule['hora_fin']:
                            # Verificar si el slot NO está en las citas existentes
                            slot_key = (nurse_id, current_date, slot_time.strftime('%H:%M'))
                            if slot_key not in booked_slots:
                                is_available = True
                                break # Enfermero disponible en este slot
                    if is_available:
                        available_nurses_for_slot.append(nurse_id)

                if available_nurses_for_slot:
                    availability_data[date_str][slot_time.strftime('%H:%M')] = available_nurses_for_slot

            current_date += timedelta(days=1)


        # Devolver JSON para el calendario
        # Formato: {'YYYY-MM-DD': {'HH:MM': [nurse_id1, nurse_id2], ...}, ...}
        return JsonResponse(availability_data, safe=False)

class CallCenterNursesForSlotAPIView(LoginRequiredMixin, View):
     def get(self, request, *args, **kwargs):
        zona_id = request.GET.get('zona_id')
        date_str = request.GET.get('date')
        time_str = request.GET.get('time') # Espera HH:MM

        if not zona_id or not date_str or not time_str:
            return JsonResponse({'error': 'Parámetros zona_id, date, time requeridos'}, status=400)

        try:
            target_date = datetime.strptime(date_str, '%Y-%m-%d').date()
            target_time = datetime.strptime(time_str, '%H:%M').time()
        except ValueError:
             return JsonResponse({'error': 'Formato de fecha (YYYY-MM-DD) o hora (HH:MM) inválido'}, status=400)

        # 1. Encontrar enfermeros para la zona
        nurses_in_zone = User.objects.filter(rol='enfermero', zonas__id=zona_id, is_active=True)

        available_nurses_details = []
        for nurse in nurses_in_zone:
            # 2. Verificar Schedule
            has_schedule = Schedule.objects.filter(
                enfermero=nurse,
                fecha=target_date,
                hora_inicio__lte=target_time,
                hora_fin__gt=target_time, # gt porque la cita empieza a esa hora
                disponible=True
            ).exists()

            if has_schedule:
                # 3. Verificar Citas Existentes
                has_conflict = Appointment.objects.filter(
                    enfermero=nurse,
                    fecha=target_date,
                    hora=target_time # Conflicto exacto a esa hora
                    # Podrías necesitar lógica más compleja si las citas duran > 1 slot
                ).exists()

                if not has_conflict:
                    available_nurses_details.append({
                        'id': nurse.id,
                        'nombre': nurse.nombres
                    })

        return JsonResponse(available_nurses_details, safe=False)

class CallCenterFindCreatePatientAPIView(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        try:
            data = json.loads(request.body)
            cedula = data.get('cedula')

            if not cedula:
                return JsonResponse({'error': 'Cédula requerida para buscar o crear paciente.'}, status=400)

            customer = CustomerProfile.objects.filter(cedula=cedula).first()

            if customer:
                return JsonResponse({
                    'status': 'found',
                    'patient_id': customer.id,
                    'nombre': customer.nombres,
                    'apellido': customer.apellidos,
                    'telefono': customer.telefono,
                    'email': customer.email,
                    'direccion': customer.direccion, # Devolver más datos si es útil para el form
                    'ciudad_id': customer.ciudad_id,
                    'zona_id': customer.zona_id,
                    'mapa': customer.ubicacion_mapa,
                })
            else:
                # Paciente no encontrado.
                # Ahora, verificamos si se enviaron datos para crear o solo para buscar.
                # Si 'nombres' (u otro campo obligatorio aparte de cedula) está presente, intentamos crear.
                if data.get('nombres') and data.get('apellidos') and data.get('telefono'): # Ajusta según tus campos requeridos
                    form = CustomerProfileForm(data)
                    if form.is_valid():
                        new_customer = form.save(commit=False)
                        new_customer.registrado_por = request.user # Asignar el operador actual
                        new_customer.save()
                        return JsonResponse({
                            'status': 'created',
                            'patient_id': new_customer.id,
                            'nombre': new_customer.nombres,
                            'apellido': new_customer.apellidos,
                            'telefono': new_customer.telefono,
                            'email': new_customer.email,
                            'cedula': new_customer.cedula,
                        }, status=201)
                    else:
                        # Faltan datos o son inválidos para la creación
                        return JsonResponse({
                            'status': 'validation_error_on_create',
                            'message': 'Datos incompletos o inválidos para crear el nuevo paciente.',
                            'errors': form.errors
                        }, status=400)
                else:
                    # Solo se envió cédula y no se encontró el paciente.
                    # Informar al frontend que debe solicitar más datos para la creación.
                    return JsonResponse({
                        'status': 'not_found_enter_details',
                        'message': 'Paciente no encontrado. Por favor, ingrese los detalles para crearlo.'
                        # No es un error 400 aquí, es un estado esperado.
                    })

        except json.JSONDecodeError:
            return JsonResponse({'error': 'JSON inválido en la solicitud.'}, status=400)
        except Exception as e:
            # Loggear el error 'e'
            print(f"Error en CallCenterFindCreatePatientAPIView: {e}")
            return JsonResponse({'error': 'Ocurrió un error interno en el servidor.'}, status=500)

class CallCenterAppointmentCreateView(LoginRequiredMixin, View):
    template_name = 'main/appointments/callcenter_create_form.html'

    def get(self, request, *args, **kwargs):
        context = {
            'title': "Agendar Cita (Call Center)",
            'subtitle': "Nuevo Agendamiento",
            'ciudades': City.objects.all(),
            'servicios': Service.objects.filter(activo=True),
            'appointment_statuses': AppointmentStatus.objects.all(), # <-- PASAR ESTADOS
            # --- >>> AÑADIR ESTA LÍNEA PARA PASAR PRODUCTOS <<< ---
            'products': Product.objects.filter(activo=True).order_by('nombre'), # Pasa todos los productos activos
            # --- >>> FIN DE LÍNEA A AÑADIR <<< ---
        }
        return render(request, self.template_name, context)

    @transaction.atomic
    def post(self, request, *args, **kwargs):
        try:
            data = json.loads(request.body)

            # Extraer datos necesarios:
            patient_id = data.get('patient_id')
            service_id = data.get('service_id')
            nurse_id = data.get('nurse_id')
            app_date_str = data.get('application_date')
            app_time_str = data.get('application_time')
            status_id = data.get('status_id') # <-- RECIBIR STATUS_ID
            tipo_ubicacion = data.get('tipo_ubicacion', 'domicilio')
            ubicacion_manual = data.get('ubicacion_manual', '')
            mapa_manual = data.get('mapa_manual', '')
            producto_id = data.get('producto_id') # Se maneja más abajo
            notas_cita = data.get('notas', '')
            doctor_name_cita = data.get('doctor_name', '')

            requires_removal = data.get('requires_removal', False)
            rem_date_str = data.get('removal_date')
            rem_time_str = data.get('removal_time')

            # --- Validación Rigurosa de Datos Esenciales ---
            if not all([patient_id, service_id, nurse_id, app_date_str, app_time_str, status_id]):
                 raise ValueError("Faltan datos esenciales: Paciente, Servicio, Enfermero, Fecha, Hora o Estado de la cita.")

            app_date = datetime.strptime(app_date_str, '%Y-%m-%d').date()
            app_time = datetime.strptime(app_time_str, '%H:%M').time()

            paciente = get_object_or_404(CustomerProfile, pk=patient_id)
            servicio = get_object_or_404(Service, pk=service_id)
            enfermero = get_object_or_404(User, pk=nurse_id, rol='enfermero')
            selected_status = get_object_or_404(AppointmentStatus, pk=status_id) # <-- OBTENER ESTADO POR ID

            producto = None # Inicializar
            if producto_id: # Solo buscar si se envió un producto_id
                producto = Product.objects.filter(id=producto_id).first()

            # --- Determinar Ubicación ---
            ubicacion_cita = ""
            mapa_cita = ""
            if tipo_ubicacion == 'domicilio':
                if not paciente.direccion: # Solo la dirección es estrictamente necesaria para copiar
                     raise ValueError("El paciente no tiene dirección registrada para cita a domicilio.")
                ubicacion_cita = paciente.direccion
                mapa_cita = paciente.ubicacion_mapa or "" # Puede ser None o vacío
            elif tipo_ubicacion == 'otro':
                if not ubicacion_manual: # Solo la ubicación es estrictamente necesaria
                     raise ValueError("Se requiere la dirección para el tipo 'otra ubicación'.")
                ubicacion_cita = ubicacion_manual
                mapa_cita = mapa_manual or ""
            else:
                 raise ValueError("Tipo de ubicación inválido.")

            # --- Encontrar Schedule para Aplicación ---
            try:
                app_schedule = Schedule.objects.get(
                    enfermero=enfermero,
                    fecha=app_date,
                    hora_inicio__lte=app_time,
                    hora_fin__gt=app_time, # gt porque la cita empieza a esa hora
                    disponible=True
                )
            except Schedule.DoesNotExist:
                 raise ValueError(f"No hay horario de trabajo definido para el enfermero {enfermero.nombres} en {app_date} a las {app_time}.")

            # --- Validar Conflicto para Aplicación ---
            # (Considera la duración del servicio si es variable)
            app_conflict = Appointment.objects.filter(
                enfermero=enfermero, fecha=app_date, hora=app_time
            ).exists()
            if app_conflict:
                 raise ValueError(f"Conflicto: Ya existe una cita para el enfermero {enfermero.nombres} en {app_date} a las {app_time}.")

            # 2. Crear Cita de Aplicación
            appointment_app = Appointment.objects.create(
                paciente=paciente,
                servicio=servicio,
                enfermero=enfermero,
                horario=app_schedule,
                fecha=app_date,
                hora=app_time,
                tipo_ubicacion=tipo_ubicacion,
                ubicacion=ubicacion_cita,
                mapa_ubicacion=mapa_cita,
                estado=selected_status, # <-- USAR ESTADO SELECCIONADO
                asignado_por=request.user,
                producto=producto,
                notas=notas_cita,
                doctor_name=doctor_name_cita,
            )

            # 3. Crear Cita de Retiro (si aplica)
            if servicio.requires_removal and requires_removal: # verifica el flag del modelo y el input del form
                if not rem_date_str or not rem_time_str:
                    raise ValueError("Faltan fecha/hora para la cita de retiro.")

                rem_date = datetime.strptime(rem_date_str, '%Y-%m-%d').date()
                rem_time = datetime.strptime(rem_time_str, '%H:%M').time()

                if datetime.combine(rem_date, rem_time) <= datetime.combine(app_date, app_time):
                     raise ValueError("La hora de retiro debe ser posterior a la de aplicación.")

                try:
                    rem_schedule = Schedule.objects.get(
                        enfermero=enfermero,
                        fecha=rem_date,
                        hora_inicio__lte=rem_time,
                        hora_fin__gt=rem_time,
                        disponible=True
                    )
                except Schedule.DoesNotExist:
                     raise ValueError(f"El enfermero {enfermero.nombres} no tiene horario de trabajo definido para el retiro en {rem_date} a las {rem_time}.")

                rem_conflict = Appointment.objects.filter(
                    enfermero=enfermero, fecha=rem_date, hora=rem_time
                ).exists()
                if rem_conflict:
                     raise ValueError(f"Conflicto: Ya existe una cita para el enfermero {enfermero.nombres} en {rem_date} a las {rem_time} (retiro).")

                Appointment.objects.create(
                    paciente=paciente,
                    servicio=servicio, # Podrías tener un servicio específico para "Retiro"
                    enfermero=enfermero,
                    horario=rem_schedule,
                    fecha=rem_date,
                    hora=rem_time,
                    tipo_ubicacion=tipo_ubicacion, # Asume misma ubicación
                    ubicacion=ubicacion_cita,
                    mapa_ubicacion=mapa_cita,
                    estado=selected_status, # Asume mismo estado inicial para retiro
                    asignado_por=request.user,
                    notas=f"CITA DE RETIRO (Aplicación original: {app_date_str} {app_time_str}). {notas_cita}",
                )

            return JsonResponse({'status': 'success', 'message': 'Cita(s) creada(s) exitosamente.'})

        except (ValueError, json.JSONDecodeError) as e: # ValueError para nuestras validaciones
             return JsonResponse({'status': 'error', 'message': str(e)}, status=400)
        # Captura explícita de DoesNotExist para cada get_object_or_404 (ya lo hace Django, pero por claridad)
        except CustomerProfile.DoesNotExist:
            return JsonResponse({'status': 'error', 'message': 'Paciente no encontrado.'}, status=404)
        except Service.DoesNotExist:
            return JsonResponse({'status': 'error', 'message': 'Servicio no encontrado.'}, status=404)
        except User.DoesNotExist: # Específicamente para el enfermero
            return JsonResponse({'status': 'error', 'message': 'Enfermero no encontrado.'}, status=404)
        except AppointmentStatus.DoesNotExist:
            return JsonResponse({'status': 'error', 'message': 'Estado de cita seleccionado no es válido.'}, status=404)
        except Exception as e:
            print(f"Error interno en POST /citas/callcenter/crear/: {type(e).__name__} - {e}")
            import traceback
            traceback.print_exc()
            return JsonResponse({'status': 'error', 'message': 'Ocurrió un error interno inesperado. Revise los logs del servidor.'}, status=500)



class CallCenterAppointmentListView(LoginRequiredMixin, ListView):
    model = Appointment
    template_name = 'main/appointments/callcenter_appointment_list.html' # Nueva plantilla para la lista
    context_object_name = 'appointments'
    paginate_by = 15 # Paginación opcional

    def get_queryset(self):
        # Puedes tener un queryset diferente para el call center si es necesario
        # Por ahora, usamos el mismo que la lista general, optimizado
        return Appointment.objects.select_related(
            'paciente', 'servicio', 'enfermero', 'estado', 'horario'
        ).prefetch_related(
            'producto'
        ).order_by('-fecha', '-hora')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Listado Citas (Call Center)"
        context['subtitle'] = "Gestión de Citas Agendadas"
        # Puedes añadir filtros específicos del call center aquí si es necesario
        return context

# Si necesitas una vista de Detalle específica para el Call Center (opcional)
class CallCenterAppointmentDetailView(LoginRequiredMixin, DetailView):
    model = Appointment
    template_name = 'main/appointments/callcenter_appointment_detail.html' # Nueva plantilla detalle
    context_object_name = 'appointment'
    # ... (puedes añadir contexto específico) ...

class CallCenterAppointmentUpdateView(LoginRequiredMixin, UpdateView):
    model = Appointment
    form_class = AppointmentForm # Puedes usar el form original o crear uno específico si es necesario
    template_name = 'main/appointments/callcenter_appointment_form_edit.html' # Nueva plantilla para editar
    # O podrías reutilizar 'main/appointments/appointment_form1.html' si es adecuado

    # Redirigir a la lista del call center después de editar
    success_url = reverse_lazy('appointments:callcenter-appointment-list')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Editar Cita (Call Center)"
        context['subtitle'] = "Modificar datos de agendamiento"
        context['is_edit_mode'] = True # Flag para la plantilla, si es necesario
        # Podrías necesitar añadir aquí lógica similar a la AppointmentUpdateView original
        # para pre-cargar datos iniciales para selects dinámicos si reutilizas ese tipo de formulario.
        # Por simplicidad, aquí usamos el AppointmentForm básico. Si necesitas la lógica
        # dinámica del formulario de creación (APIs, etc.) al editar, esta vista
        # debería heredar de View y reimplementar GET y POST como CallCenterAppointmentCreateView
        # pero cargando el objeto existente. ¡Esto es más complejo!
        return context

    def form_valid(self, form):
        # Puedes añadir lógica aquí antes de guardar si es necesario
        return super().form_valid(form)


class CallCenterAppointmentDeleteView(LoginRequiredMixin, DeleteView):
    model = Appointment
    template_name = 'main/appointments/callcenter_appointment_confirm_delete.html' # Nueva plantilla confirmación
    # Redirigir a la lista del call center después de eliminar
    success_url = reverse_lazy('appointments:callcenter-appointment-list')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Eliminar Cita (Call Center)"
        context['subtitle'] = f"Confirmar eliminación de cita para {self.object.paciente}"
        return context


"catalog_admin.txt"
from django.contrib import admin
from .models import Service, Product

@admin.register(Service)
class ServiceAdmin(admin.ModelAdmin):
    list_display = ('nombre', 'precio', 'activo')
    list_filter = ('activo',)
    search_fields = ('nombre',)

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ('nombre', 'precio', 'cantidad_disponible', 'activo')
    list_filter = ('activo',)
    search_fields = ('nombre',)


"catalog_forms.txt"
from django import forms
from .models import Service, Product

class ServiceForm(forms.ModelForm):
    class Meta:
        model = Service
        fields = ['nombre', 'descripcion', 'precio', 'activo']
        widgets = {
            'nombre': forms.TextInput(attrs={'class': 'form-control'}),
            'descripcion': forms.Textarea(attrs={'class': 'form-control', 'rows':3}),
            'precio': forms.NumberInput(attrs={'class': 'form-control'}),
            'activo': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
        }

class ProductForm(forms.ModelForm):
    class Meta:
        model = Product
        fields = ['nombre', 'descripcion', 'precio', 'cantidad_disponible', 'activo']
        widgets = {
            'nombre': forms.TextInput(attrs={'class': 'form-control'}),
            'descripcion': forms.Textarea(attrs={'class': 'form-control', 'rows':3}),
            'precio': forms.NumberInput(attrs={'class': 'form-control'}),
            'cantidad_disponible': forms.NumberInput(attrs={'class': 'form-control'}),
            'activo': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
        }


"catalog_models.txt"
#CoreApps/catalog/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _

class Service(models.Model):
    #neptuno agregar
    nombre = models.CharField(_("Nombre del servicio"), max_length=100)
    descripcion = models.TextField(_("Descripción del servicio"), blank=True)
    precio = models.DecimalField(_("Precio"), max_digits=8, decimal_places=2)
    activo = models.BooleanField(_("Activo"), default=True)
    # --- NUEVO CAMPO --- g 
    requires_removal = models.BooleanField(
        _("Requiere Cita de Retiro"),
        default=False,
        help_text=_("Marcar si este servicio necesita una cita de seguimiento para retiro (ej. Suero).")
    )
    # --- FIN NUEVO CAMPO ---
    class Meta:
        verbose_name = _("Servicio")
        verbose_name_plural = _("Servicios")

    def __str__(self):
        return self.nombre

class Product(models.Model):
    #neptuno agregar campo
    nombre = models.CharField(_("Nombre del producto"), max_length=100)
    descripcion = models.TextField(_("Descripción del producto"), blank=True)
    precio = models.DecimalField(_("Precio"), max_digits=8, decimal_places=2)
    cantidad_disponible = models.PositiveIntegerField(_("Cantidad disponible"), default=0)
    activo = models.BooleanField(_("Activo"), default=True)

    class Meta:
        verbose_name = _("Producto")
        verbose_name_plural = _("Productos")

    def __str__(self):
        return self.nombre


"catalog_urls.txt"
from django.urls import path
from . import views

app_name = 'catalog'

urlpatterns = [
    # Servicios
    path('servicios/', views.ServiceListView.as_view(), name='service-list'),
    path('servicios/nuevo/', views.ServiceCreateView.as_view(), name='service-create'),
    path('servicios/<int:pk>/editar/', views.ServiceUpdateView.as_view(), name='service-update'),
    path('servicios/<int:pk>/eliminar/', views.ServiceDeleteView.as_view(), name='service-delete'),

    # Productos
    path('productos/', views.ProductListView.as_view(), name='product-list'),
    path('productos/nuevo/', views.ProductCreateView.as_view(), name='product-create'),
    path('productos/<int:pk>/editar/', views.ProductUpdateView.as_view(), name='product-update'),
    path('productos/<int:pk>/eliminar/', views.ProductDeleteView.as_view(), name='product-delete'),
]


"catalog_views.txt"
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import ListView, CreateView, UpdateView, DeleteView
from django.urls import reverse_lazy
from .models import Service, Product
from .forms import ServiceForm, ProductForm

# CRUD Services
class ServiceListView(LoginRequiredMixin, ListView):
    model = Service
    template_name = 'main/catalog/service_list.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        # Otros datos de contexto (título, subtítulo, etc.)
        context['title'] = "Servicios"
        context['subtitle'] = "Lista de servicios"
        context['user'] = user
        return context

class ServiceCreateView(LoginRequiredMixin, CreateView):
    model = Service
    form_class = ServiceForm
    template_name = 'main/catalog/service_form.html'
    success_url = reverse_lazy('catalog:service-list')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        # Otros datos de contexto (título, subtítulo, etc.)
        context['title'] = "Nuevo Servicio"
        context['subtitle'] = "Nuevo"
        context['user'] = user
        return context

class ServiceUpdateView(LoginRequiredMixin, UpdateView):
    model = Service
    form_class = ServiceForm
    template_name = 'main/catalog/service_form.html'
    success_url = reverse_lazy('catalog:service-list')

class ServiceDeleteView(LoginRequiredMixin, DeleteView):
    model = Service
    template_name = 'main/catalog/service_confirm_delete.html'
    success_url = reverse_lazy('catalog:service-list')

# CRUD Products
class ProductListView(LoginRequiredMixin, ListView):
    model = Product
    template_name = 'main/catalog/product_list.html'

    def get_context_data(self, **kwargs):
       context = super().get_context_data(**kwargs)
       user = self.request.user
       # Otros datos de contexto (título, subtítulo, etc.)
       context['title'] = "Productos"
       context['subtitle'] = "Lista de Productos"
       context['user'] = user
       return context

class ProductCreateView(LoginRequiredMixin, CreateView):
    model = Product
    form_class = ProductForm
    template_name = 'main/catalog/product_form.html'
    success_url = reverse_lazy('catalog:product-list')

    def get_context_data(self, **kwargs):
       context = super().get_context_data(**kwargs)
       user = self.request.user
       # Otros datos de contexto (título, subtítulo, etc.)
       context['title'] = "Nuevo Producto"
       context['subtitle'] = "Nuevo"
       context['user'] = user
       return context

class ProductUpdateView(LoginRequiredMixin, UpdateView):
    model = Product
    form_class = ProductForm
    template_name = 'main/catalog/product_form.html'
    success_url = reverse_lazy('catalog:product-list')

class ProductDeleteView(LoginRequiredMixin, DeleteView):
    model = Product
    template_name = 'main/catalog/product_confirm_delete.html'
    success_url = reverse_lazy('catalog:product-list')


"core_admin.txt"
from django.contrib import admin
from .models import City, Zona

@admin.register(City)
class CityAdmin(admin.ModelAdmin):
    list_display = ('nombre',)
    search_fields = ('nombre',)

@admin.register(Zona)               # ← Registra Zona
class ZonaAdmin(admin.ModelAdmin):
    list_display   = ('nombre', 'ciudad')
    list_filter    = ('ciudad',)
    search_fields  = ('nombre',)

"core_models.txt"
#CoreApps/core/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _

class City(models.Model):
    nombre = models.CharField(_("Ciudad"), max_length=100, unique=True)

    class Meta:
        verbose_name = _("Ciudad")
        verbose_name_plural = _("Ciudades")
        ordering = ['nombre']

    def __str__(self):
        return self.nombre

class Zona(models.Model):
    ciudad = models.ForeignKey(
        City,
        on_delete=models.CASCADE,
        related_name='zonas'
    )
    nombre = models.CharField(_("Zona"), max_length=100)

    class Meta:
        verbose_name = _("Zona")
        verbose_name_plural = _("Zonas")
        unique_together = ('ciudad', 'nombre')
        ordering = ['ciudad__nombre', 'nombre']

    def __str__(self):
        return f"{self.nombre} ({self.ciudad.nombre})"

"customers_admin.txt"
from django.contrib import admin
from .models import CustomerProfile, MedicalHistory

@admin.register(CustomerProfile)
class CustomerProfileAdmin(admin.ModelAdmin):
    list_display = (
        'cedula', 'nombres', 'apellidos',
        'telefono', 'ciudad', 'zona',
        'ubicacion_mapa',   # ← campo nuevo
        'registrado_por', 'fecha_registro'
    )
    search_fields = (
        'cedula', 'nombres', 'apellidos',
        'telefono', 'email', 'ciudad__nombre',
        'ubicacion_mapa'    # ← incluye en búsqueda
    )
    list_filter = ('ciudad', 'fecha_registro', 'registrado_por')

@admin.register(MedicalHistory)
class MedicalHistoryAdmin(admin.ModelAdmin):
    list_display = ('customer', 'descripcion', 'fecha_registro')
    search_fields = ('customer__cedula', 'customer__nombres')
    list_filter = ('fecha_registro',)


"customers_forms.txt"
from django import forms
from .models import CustomerProfile, MedicalHistory

class CustomerProfileForm(forms.ModelForm):
    class Meta:
        model = CustomerProfile
        #fields = ['nombres', 'apellidos', 'cedula', 'telefono', 'email', 'direccion', 'ciudad', 'fecha_nacimiento']
        fields = [
            'nombres','apellidos','cedula','telefono','email','ciudad','zona',
            'direccion','ubicacion_mapa','fecha_nacimiento'
        ]
        widgets = {
            'nombres': forms.TextInput(attrs={'class': 'form-control'}),
            'apellidos': forms.TextInput(attrs={'class': 'form-control'}),
            'cedula': forms.TextInput(attrs={'class': 'form-control'}),
            'telefono': forms.TextInput(attrs={'class': 'form-control'}),
            'email': forms.EmailInput(attrs={'class': 'form-control'}),
            'ciudad': forms.Select(attrs={'class':'form-control'}),
            'zona':   forms.Select(attrs={'class':'form-control'}),
            'direccion': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'ubicacion_mapa': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://maps.google.com/…'
            }),
            #'ciudad': forms.Select(attrs={'class': 'form-control'}),  # Corrección aquí
            'fecha_nacimiento': forms.DateInput(attrs={'type': 'date', 'class': 'form-control'}),
        }

class MedicalHistoryForm(forms.ModelForm):
    class Meta:
        model = MedicalHistory
        fields = ['descripcion']
        widgets = {
            'descripcion': forms.Textarea(attrs={'class': 'form-control', 'rows': 4}),
        }


"customers_models.txt"
#CoreApps/curtomers/models.py
from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _
from CoreApps.core.models import City, Zona

class CustomerProfile(models.Model):
    nombres = models.CharField(_("Nombres"), max_length=100)
    apellidos = models.CharField(_("Apellidos"), max_length=100)
    cedula = models.CharField(_("Cédula"), max_length=20, unique=True)
    telefono = models.CharField(_("Teléfono"), max_length=20)
    email = models.EmailField(_("Correo electrónico"), blank=True, null=True)
    direccion = models.TextField(_("Dirección completa"))
    ubicacion_mapa = models.URLField(
        _("Ubicación en Google Maps"),
        max_length=500,
        blank=True,
        null=True,
        help_text=_("Enlace a Google Maps (https://maps.google.com/…) para esta dirección")
    )
    ciudad = models.ForeignKey(City, on_delete=models.PROTECT, related_name='clientes', blank=True, null=True) # <-- nuevo campo
    zona = models.ForeignKey(Zona,on_delete=models.PROTECT, related_name='clientes', verbose_name=_("Zona"), blank=True, null=True)
    fecha_nacimiento = models.DateField(_("Fecha de nacimiento"), blank=True, null=True)
    fecha_registro = models.DateTimeField(_("Fecha de registro"), auto_now_add=True)
    registrado_por = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        verbose_name=_("Registrado por"),
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="clientes_registrados"
    )
    class Meta:
        verbose_name = _("Cliente")
        verbose_name_plural = _("Clientes")

    def __str__(self):
        return f"{self.nombres} ({self.cedula})"


class MedicalHistory(models.Model):
    customer = models.ForeignKey(CustomerProfile, on_delete=models.CASCADE, related_name='medical_histories')
    descripcion = models.TextField(_("Descripción médica"))
    fecha_registro = models.DateTimeField(_("Fecha de registro"), auto_now_add=True)

    class Meta:
        verbose_name = _("Historial Médico")
        verbose_name_plural = _("Historiales Médicos")

    def __str__(self):
        return f"Historial de {self.customer.nombres} - {self.fecha_registro.strftime('%Y-%m-%d')}"


"customers_urls.txt"
from django.urls import path
from . import views

app_name = 'customers'

urlpatterns = [
    path('', views.CustomerListView.as_view(), name='customer-list'),
    path('nuevo/', views.CustomerCreateView.as_view(), name='customer-create'),
    path('detalle/<int:pk>/', views.CustomerDetailView.as_view(), name='customer-detail'),
    path('editar/<int:pk>/', views.CustomerUpdateView.as_view(), name='customer-update'),
    path('eliminar/<int:pk>/', views.CustormerDeleteView.as_view(), name='customer-delete'),
    path('api/zonas/', views.obtener_zonas_por_ciudad, name='api-obtener-zonas'),
]


"customers_views.txt"
from django.shortcuts import render
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import ListView, CreateView, DetailView, UpdateView, DeleteView
from django.urls import reverse_lazy
from .models import CustomerProfile
from .forms import CustomerProfileForm
from CoreApps.core.models import Zona
from django.http import JsonResponse

class CustomerListView(LoginRequiredMixin, ListView):
    model = CustomerProfile
    #template_name = 'main/customers/customer_list.html'
    template_name = 'main/customers/customer_list.html'
    context_object_name = 'customers'

    def get_queryset(self):
        return CustomerProfile.objects.select_related('ciudad', 'zona').all()


    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        # Otros datos de contexto (título, subtítulo, etc.)
        context['title'] = "Clientes"
        context['subtitle'] = "Lista de clientes"
        context['user'] = user
        return context

class CustomerCreateView(LoginRequiredMixin, CreateView):
    model = CustomerProfile
    form_class = CustomerProfileForm
    template_name = 'main/customers/customer_form.html'
    success_url = reverse_lazy('customers:customer-list')

    def form_valid(self, form):
        form.instance.registrado_por = self.request.user
        return super().form_valid(form)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        # Otros datos de contexto (título, subtítulo, etc.)
        context['title'] = "Nuevo Cliente"
        context['subtitle'] = "Nuevo"
        context['zona_inicial'] = None
        context['user'] = user
        return context

class CustomerDetailView(LoginRequiredMixin, DetailView):
    model = CustomerProfile
    template_name = 'main/customers/customer_detail.html'
    context_object_name = 'customer'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        # Otros datos de contexto (título, subtítulo, etc.)
        context['title'] = "Nuevo Cliente"
        context['subtitle'] = "Nuevo"
        context['user'] = user
        return context

class CustomerUpdateView(LoginRequiredMixin, UpdateView):
    model = CustomerProfile
    form_class = CustomerProfileForm
    template_name = 'main/customers/customer_form.html'
    success_url = reverse_lazy('customers:customer-list')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        # Otros datos de contexto (título, subtítulo, etc.)
        context['title'] = "Editar Cliente"
        context['subtitle'] = "Editar"
        context['zona_inicial'] = self.object.zona_id
        context['user'] = user
        return context

class CustormerDeleteView(LoginRequiredMixin, DeleteView):
    model = CustomerProfile
    template_name = 'main/customers/customer_confirm_delete.html'
    success_url = reverse_lazy('customers:customer-list')

def obtener_zonas_por_ciudad(request):
    """
    Endpoint que recibe GET?ciudad_id=… y devuelve
    [{'id': zona_id, 'nombre': zona_nombre}, …]
    """
    ciudad_id = request.GET.get('ciudad_id')
    if not ciudad_id:
        return JsonResponse([], safe=False)

    qs = Zona.objects.filter(ciudad_id=ciudad_id).values('id', 'nombre')
    data = [{'id': z['id'], 'nombre': z['nombre']} for z in qs]
    return JsonResponse(data, safe=False)


"main_views.txt"
from django.shortcuts import render
from django.contrib.auth.views import LoginView, LogoutView
from django.views.generic.edit import CreateView, UpdateView, DeleteView
from django.views.generic.list import ListView
from django.urls import reverse_lazy
from CoreApps.users.forms import CustomUserCreationForm
from django.contrib.auth import login
from CoreApps.users.models import User
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from CoreApps.users.models import User
from CoreApps.customers.models import CustomerProfile
# Añadir esta importación para JsonResponse
from django.http import JsonResponse
from django.conf import settings
from datetime import datetime

class CustomLoginView(LoginView):
    template_name = 'main/login.html'
    def get_success_url(self):
        return reverse_lazy('dashboard')

    def form_invalid(self, form):
        messages.error(self.request, 'Por favor verifica tus credenciales e intenta nuevamente.')
        return super().form_invalid(form)

class SignUpView(CreateView):
    form_class = CustomUserCreationForm
    template_name = 'main/signup.html'
    success_url = reverse_lazy('login')

    def form_valid(self, form):
        form.instance.user_type = User.UserType.CLIENT
        response = super().form_valid(form)
        login(self.request, self.object)
        return response

class DashboardView(LoginRequiredMixin, TemplateView):
    template_name = 'main/dashboard/main_dashboard.html'
    login_url = 'login'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        # Otros datos de contexto (título, subtítulo, etc.)
        context['title'] = "Dashboard"
        context['subtitle'] = "Dashboard"
        context['user'] = user
        return context



"reports_admin.txt"
from django.contrib import admin
from .models import Report, ConsentOrPrescription

@admin.register(Report)
class ReportAdmin(admin.ModelAdmin):
    list_display = ('appointment', 'enfermero', 'fecha_hora_reporte', 'valoracion')
    search_fields = ('appointment__paciente__nombres', 'appointment__servicio__nombre', 'enfermero__nombres')
    list_filter = ('valoracion', 'fecha_hora_reporte')
    date_hierarchy = 'fecha_hora_reporte'
    raw_id_fields = ('appointment', 'enfermero')

@admin.register(ConsentOrPrescription)
class ConsentOrPrescriptionAdmin(admin.ModelAdmin):
    list_display = ('report', 'tipo', 'fecha_hora_creacion')
    search_fields = ('report__appointment__paciente__nombres', 'tipo')
    list_filter = ('tipo', 'fecha_hora_creacion')
    date_hierarchy = 'fecha_hora_creacion'
    raw_id_fields = ('report',)


"reports_forms.txt"
from django import forms
from .models import Report, ConsentOrPrescription

class ReportForm(forms.ModelForm):
    class Meta:
        model = Report
        fields = ['appointment', 'ubicacion_gps', 'notas_novedades', 'valoracion']
        widgets = {
            'appointment': forms.Select(attrs={'class': 'form-control'}),
            'ubicacion_gps': forms.URLInput(attrs={'class': 'form-control'}),
            'notas_novedades': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'valoracion': forms.NumberInput(attrs={'class': 'form-control', 'min': 1, 'max': 5}),
        }

class ConsentOrPrescriptionForm(forms.ModelForm):
    class Meta:
        model = ConsentOrPrescription
        fields = ['report', 'tipo', 'imagen_receta', 'firma_digital']
        widgets = {
            'report': forms.Select(attrs={'class': 'form-control'}),
            'tipo': forms.Select(attrs={'class': 'form-control'}),
            'imagen_receta': forms.ClearableFileInput(attrs={'class': 'form-control'}),
            'firma_digital': forms.ClearableFileInput(attrs={'class': 'form-control'}),
        }


"reports_models.txt"
#CoreApps/reports/models.py
from django.db import models
from django.conf import settings
from CoreApps.appointments.models import Appointment
from django.utils.translation import gettext_lazy as _

class Report(models.Model):
    appointment = models.OneToOneField(
        Appointment, on_delete=models.CASCADE,
        related_name='reporte', verbose_name=_("Cita relacionada")
    )
    enfermero = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL, null=True, related_name='reportes'
    )
    ubicacion_gps = models.URLField(
        _("Ubicación GPS enfermero"), max_length=500,
        help_text=_("Ubicación del enfermero durante el reporte (link de mapa)")
    )
    notas_novedades = models.TextField(_("Novedades de la cita"))
    valoracion = models.PositiveSmallIntegerField(_("Valoración del servicio"), default=5)
    fecha_hora_reporte = models.DateTimeField(_("Fecha y hora del reporte"), auto_now_add=True)

    class Meta:
        verbose_name = _("Reporte de visita")
        verbose_name_plural = _("Reportes de visitas")

    def __str__(self):
        return f"Reporte - {self.appointment} - {self.fecha_hora_reporte}"

class ConsentOrPrescription(models.Model):
    CONSENTIMIENTO = 'consentimiento'
    RECETA = 'receta'
    TIPO_CHOICES = [
        (CONSENTIMIENTO, 'Consentimiento Informado'),
        (RECETA, 'Receta Médica'),
    ]

    report = models.OneToOneField(
        Report, on_delete=models.CASCADE,
        related_name='consentimiento_o_receta', verbose_name=_("Reporte relacionado")
    )
    tipo = models.CharField(_("Tipo"), max_length=20, choices=TIPO_CHOICES)
    # Para recetas médicas:
    imagen_receta = models.ImageField(
        _("Imagen de la receta"), upload_to='recetas/', blank=True, null=True
    )
    # Para consentimiento informado:
    firma_digital = models.ImageField(
        _("Firma digital"), upload_to='firmas/', blank=True, null=True
    )
    documento_generado = models.FileField(
        _("Documento generado"), upload_to='documentos/', blank=True, null=True
    )
    fecha_hora_creacion = models.DateTimeField(_("Fecha y hora creación"), auto_now_add=True)

    class Meta:
        verbose_name = _("Consentimiento o receta")
        verbose_name_plural = _("Consentimientos y recetas")

    def __str__(self):
        return f"{self.get_tipo_display()} - {self.report}"


"reports_urls.txt"
from django.urls import path
from . import views

app_name = 'reports'

urlpatterns = [
    path('', views.ReportListView.as_view(), name='report-list'),
    path('crear/', views.ReportCreateView.as_view(), name='report-create'),
    path('<int:pk>/detalle/', views.ReportDetailView.as_view(), name='report-detail'),
    path('<int:pk>/editar/', views.ReportUpdateView.as_view(), name='report-update'),
    path('<int:pk>/eliminar/', views.ReportDeleteView.as_view(), name='report-delete'),
    path('adjuntar-documento/', views.ConsentOrPrescriptionCreateView.as_view(), name='consent-or-prescription-create'),

]


"reports_views.txt"
from django.views.generic import ListView, CreateView, DetailView, UpdateView, DeleteView
from django.urls import reverse_lazy
from django.shortcuts import redirect
from django.urls import reverse
from django.contrib.auth.mixins import LoginRequiredMixin
from CoreApps.appointments.models import AppointmentStatus, Appointment
from .models import ConsentOrPrescription, Report
from .forms import ConsentOrPrescriptionForm, ReportForm
from django.shortcuts import redirect, get_object_or_404
from django.views import View
from django.shortcuts import render
from django.http import HttpResponseRedirect


from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import cm
from datetime import datetime
from io import BytesIO
from django.core.files.base import ContentFile

def generar_consentimiento_pdf(consentimiento_instance):
    """
    Genera un PDF de consentimiento y lo guarda en el campo documento_generado del consentimiento_instance.
    """
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=A4)
    width, height = A4

    paciente = consentimiento_instance.report.appointment.paciente
    cita = consentimiento_instance.report.appointment

    # Datos principales
    paciente_nombre = f"{paciente.nombres} {paciente.apellidos}"
    paciente_cedula = paciente.cedula
    fecha_cita = cita.horario.fecha.strftime('%d/%m/%Y') if cita.horario and cita.horario.fecha else "Fecha no registrada"
    hora_cita = cita.hora.strftime('%H:%M') if cita.hora else "Hora no registrada"

    # Título
    c.setFont("Helvetica-Bold", 14)
    c.drawCentredString(width / 2, height - 3*cm, "Documento de Consentimiento Informado")

    # Texto
    texto = (
        f"Yo, {paciente_nombre}, con cédula {paciente_cedula}, "
        f"acepto y doy mi consentimiento para el procedimiento aplicado el día {fecha_cita} "
        f"a las {hora_cita}. Declaro que he sido informado adecuadamente y acepto de forma voluntaria."
    )
    c.setFont("Helvetica", 12)
    c.drawString(3*cm, height - 5*cm, texto)

    # Firma
    if consentimiento_instance.firma_digital:
        firma_path = consentimiento_instance.firma_digital.path
        c.drawImage(firma_path, 3*cm, height - 14*cm, width=8*cm, preserveAspectRatio=True)

    # Pie de página
    c.setFont("Helvetica-Oblique", 10)
    c.drawString(3*cm, 3*cm, f"Fecha de generación del documento: {datetime.now().strftime('%d/%m/%Y %H:%M')}")

    c.showPage()
    c.save()

    buffer.seek(0)
    filename = f"consentimiento_{consentimiento_instance.pk}.pdf"
    consentimiento_instance.documento_generado.save(filename, ContentFile(buffer.read()))
    buffer.close()

class ConsentOrPrescriptionCreateView(LoginRequiredMixin, View):
    template_name = 'main/reports/consent_or_prescription_form.html'

    def get(self, request, *args, **kwargs):
        report_id = request.GET.get('report')
        report = get_object_or_404(Report, pk=report_id)
        instance, created = ConsentOrPrescription.objects.get_or_create(report=report)
        form = ConsentOrPrescriptionForm(instance=instance)
        return render(request, self.template_name, {'form': form})

    def post(self, request, *args, **kwargs):
        report_id = request.GET.get('report')
        report = get_object_or_404(Report, pk=report_id)
        instance, created = ConsentOrPrescription.objects.get_or_create(report=report)
        form = ConsentOrPrescriptionForm(request.POST, request.FILES, instance=instance)
        if form.is_valid():
            form.save()
            if instance.tipo == ConsentOrPrescription.CONSENTIMIENTO:
                generar_consentimiento_pdf(instance)
                instance.save()
            return redirect('reports:report-list')  # Ajusta si deseas otro destino
        return render(request, self.template_name, {'form': form})

# Lista de reportes
class ReportListView(LoginRequiredMixin, ListView):
    model = Report
    template_name = 'main/reports/report_list.html'
    context_object_name = 'reports'
    ordering = ['-fecha_hora_reporte']

    def get_queryset(self):
        qs = super().get_queryset()
        # si el usuario es enfermero, sólo sus propios reportes
        if hasattr(self.request.user, 'rol') and self.request.user.rol == 'enfermero':
            return qs.filter(enfermero=self.request.user)
        # si no (operador o administrador), todos
        return qs

# Detalle de un reporte
class ReportDetailView(LoginRequiredMixin, DetailView):
    model = Report
    template_name = 'main/reports/report_detail.html'
    context_object_name = 'report'

# Crear un reporte
"""
class ReportCreateView(LoginRequiredMixin, CreateView):
    model = Report
    form_class = ReportForm
    template_name = 'main/reports/report_form.html'

    def get_initial(self):
        initial = super().get_initial()
        initial['appointment'] = self.request.GET.get('appointment')
        return initial

    def form_valid(self, form):
        form.instance.enfermero = self.request.user
        cita = form.instance.appointment

        estado_confirmado, created = AppointmentStatus.objects.get_or_create(nombre="Confirmada")
        cita.estado = estado_confirmado
        cita.save()

        self.object = form.save()  # ← Guardas manualmente
        return redirect(
            reverse('reports:consent-or-prescription-create') + f'?report={self.object.pk}'
        )
"""
class ReportCreateView(LoginRequiredMixin, CreateView):
    model = Report
    form_class = ReportForm
    template_name = 'main/reports/report_form.html'

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        # Si es enfermero, solo sus propias citas
        if hasattr(self.request.user, 'rol') and self.request.user.rol == 'enfermero':
            form.fields['appointment'].queryset = Appointment.objects.filter(
                enfermero=self.request.user
            ).order_by('horario__fecha', 'hora')
        # Dejar sin filtrar para operadores y admins
        return form

    def get_initial(self):
        initial = super().get_initial()
        # Si vienen por ?appointment=ID, precargamos ese valor
        initial['appointment'] = self.request.GET.get('appointment')
        return initial

    def form_valid(self, form):
        form.instance.enfermero = self.request.user
        cita = form.instance.appointment

        estado_confirmado, created = AppointmentStatus.objects.get_or_create(nombre="Confirmada")
        cita.estado = estado_confirmado
        cita.save()

        self.object = form.save()
        return redirect(
            reverse('reports:consent-or-prescription-create') + f'?report={self.object.pk}'
        )

# Editar un reporte
class ReportUpdateView(LoginRequiredMixin, UpdateView):
    model = Report
    form_class = ReportForm
    template_name = 'main/reports/report_form.html'
    success_url = reverse_lazy('reports:report-list')

# Eliminar un reporte
class ReportDeleteView(LoginRequiredMixin, DeleteView):
    model = Report
    template_name = 'main/reports/report_confirm_delete.html'
    success_url = reverse_lazy('reports:report-list')


"users_admin.txt"
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from django.utils.translation import gettext_lazy as _
from .models import User
from .forms import CustomUserCreationForm, CustomUserChangeForm

@admin.register(User)
class CustomUserAdmin(UserAdmin):
    model = User
    add_form = CustomUserCreationForm
    form     = CustomUserChangeForm

    list_display = (
        'email','cedula','nombres','rol',
        'ciudad','display_zonas',
        'profile_image_display','is_staff','is_active'
    )
    list_filter = ('rol','ciudad','zonas','is_staff','is_active')
    filter_horizontal = ('groups','user_permissions','zonas')

    # Volvemos a incluir todos los bloques originales, añadiendo 'zonas' donde toca
    fieldsets = (
        (None, {'fields': ('email','password')}),
        (_('Información personal'), {
            'fields': (
                'cedula','nombres','telefono',
                'rol','profile_image',
                'ciudad','zonas'
            )
        }),
        (_('Permisos'), {
            'fields': (
                'is_active','is_staff','is_superuser',
                'groups','user_permissions'
            )
        }),
        (_('Fechas importantes'), {
            'fields': ('last_login','date_joined')
        }),
    )

    # Para crear usuarios: email+password primero, luego info personal, luego permisos
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email','password1','password2'),
        }),
        (_('Información personal'), {
            'fields': (
                'cedula','nombres','telefono',
                'rol','profile_image',
                'ciudad','zonas',
            )
        }),
        (_('Permisos'), {
            'fields': (
                'is_active','is_staff','is_superuser',
                'groups','user_permissions'
            )
        }),
    )

    search_fields = ('email','cedula','nombres','ciudad__nombre')
    ordering = ('email',)

    def display_zonas(self, obj):
        return ", ".join(z.nombre for z in obj.zonas.all())
    display_zonas.short_description = 'Zonas'

    def profile_image_display(self, obj):
        if obj.profile_image:
            return f'<img src="{obj.profile_image.url}" width="50" height="50" ' \
                   f'style="border-radius:50%;object-fit:cover;"/>'
        return "Sin Imagen"
    profile_image_display.short_description = 'Foto de perfil'
    profile_image_display.allow_tags = True


"users_forms.txt"
from django import forms
from django.contrib.auth.forms import UserCreationForm, UserChangeForm
from django.utils.translation import gettext_lazy as _
from .models import User

class CustomUserCreationForm(UserCreationForm):
    """
    Formulario para crear nuevos usuarios con nuestro modelo personalizado.
    """
    class Meta:
        model = User
        #fields = ('email', 'cedula', 'nombres', 'telefono', 'rol')
        fields = (
            'email','cedula','nombres','telefono',
            'rol','ciudad','zonas'
        )
        
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['email'].widget.attrs.update({'class': 'form-control', 'placeholder': 'Correo electrónico'})
        self.fields['cedula'].widget.attrs.update({'class': 'form-control', 'placeholder': 'Cédula'})
        self.fields['nombres'].widget.attrs.update({'class': 'form-control', 'placeholder': 'Nombres completos'})
        self.fields['telefono'].widget.attrs.update({'class': 'form-control', 'placeholder': 'Número de teléfono'})
        self.fields['rol'].widget.attrs.update({'class': 'form-select'})
        self.fields['ciudad'].widget.attrs.update({'class':'form-select'})
        self.fields['zonas'].widget.attrs.update({'class':'form-select'})

class CustomUserChangeForm(UserChangeForm):
    """
    Formulario para actualizar usuarios con nuestro modelo personalizado.
    """
    class Meta:
        model = User
        #fields = ('email', 'cedula', 'nombres', 'telefono', 'rol')
        fields = (
            'email','cedula','nombres','telefono',
            'rol','ciudad','zonas'
        )
        
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['email'].widget.attrs.update({'class': 'form-control'})
        self.fields['cedula'].widget.attrs.update({'class': 'form-control'})
        self.fields['nombres'].widget.attrs.update({'class': 'form-control'})
        self.fields['telefono'].widget.attrs.update({'class': 'form-control'})
        self.fields['rol'].widget.attrs.update({'class': 'form-select'})
        self.fields['ciudad'].widget.attrs.update({'class':'form-select'})
        self.fields['zonas'].widget.attrs.update({'class':'form-select'})

"users_models.txt"
#CoreApps/users/models.py
from django.contrib.auth.models import AbstractUser, BaseUserManager
from django.db import models
from django.utils.translation import gettext_lazy as _
from CoreApps.core.models import City, Zona

class UserManager(BaseUserManager):
    """
    Gestor personalizado para el modelo de usuario donde el email es el identificador único
    en lugar del nombre de usuario.
    """
    def create_user(self, email, password=None, **extra_fields):
        """
        Crea y guarda un usuario con el email y contraseña proporcionados.
        """
        if not email:
            raise ValueError(_('El Email es obligatorio'))
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        """
        Crea y guarda un superusuario con el email y contraseña proporcionados.
        """
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_active', True)
        extra_fields.setdefault('rol', 'operador')  # Por defecto, los superusuarios son operadores

        if extra_fields.get('is_staff') is not True:
            raise ValueError(_('Superuser debe tener is_staff=True.'))
        if extra_fields.get('is_superuser') is not True:
            raise ValueError(_('Superuser debe tener is_superuser=True.'))
        return self.create_user(email, password, **extra_fields)

class User(AbstractUser):
    """
    Modelo de usuario personalizado donde el email es el identificador único
    para autenticación en lugar del nombre de usuario.
    """
    ROL_CHOICES = (
        ('enfermero', 'Enfermero'),
        ('operador', 'Operador'),
        ('administrador', 'Administrador'),
    )
    
    username = None  # Eliminamos el campo username
    email = models.EmailField(_('correo electrónico'), unique=True)
    cedula = models.CharField(_('cédula'), max_length=20, unique=True)
    nombres = models.CharField(_('nombres completos'), max_length=100)
    telefono = models.CharField(_('número de teléfono'), max_length=20, blank=True)
    rol = models.CharField(_('rol'), max_length=20, choices=ROL_CHOICES, default='enfermero')
    profile_image = models.ImageField(upload_to='profile_images/', null=True, blank=True, verbose_name=_('foto de perfil'))
    ciudad = models.ForeignKey(City, on_delete=models.PROTECT, related_name='usuarios', blank=True, null=True) # <-- nuevo campo
    #zona = models.ForeignKey(Zona, on_delete=models.PROTECT, related_name='enfermeros', verbose_name=_("Zona"), blank=True, null=True) 
    zonas = models.ManyToManyField(Zona, related_name='enfermeros', verbose_name=_("Zonas"), blank=True)
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['cedula', 'nombres', 'rol']
    
    objects = UserManager()
    
    class Meta:
        verbose_name = _('usuario')
        verbose_name_plural = _('usuarios')
    
    def get_full_name(self):
        """
        Retorna el nombre completo del usuario.
        """
        return self.nombres
        
    def __str__(self):
        return self.email


